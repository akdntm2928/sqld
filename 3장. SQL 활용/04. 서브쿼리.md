<u>서브쿼리(Subquery)란 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문을 말한다.</u>

<u>서브쿼리는 알려지지 않은 기준을 이용한 검색을 위해 사용한다.</u>

<u>메인쿼리가 서브쿼리를 포함하는 종속관계이다.</u>



조인은 조인에 참여한느 모든 테이블이 대등한 관계에 있기 때문에 조인에 참여하는 모든 테이블의 칼럼을 어느 위치에서라도 자유롭게 사용할 수 있다.

<u>그러나 서브쿼리는 메인쿼리의 칼럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 칼럼을 사용할 수 없다.</u>

<u>질의 결과에 서브쿼리 칼럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 이용해야 한다.</u>



조인은 집합간의 곱(Product)의 관계이다.

즉, 1:1 관계의 테이블이 조인하면 1(= 1*1) 레벨의 집합이 생성되고, 1:M 레벨의 집합이 결과로서 생성된다.

<u>그러나 서브쿼리는 서브쿼리 레벨과는 상관없이 항상 메인쿼리 레벨로 결과 집합이 생성된다.</u>

예를 들어, 메인쿼리로 조직(1), 서브쿼리로 사원(M) 테이블을 사용하면 결과 집합은 조직(1)레벨이 된다.

<u>원하는 레벨이 무엇이지 생각해서 조인을 사용해야 할 지, 서브쿼리를 사용해야 할 지 생각해야 한다.</u>



서브쿼리를 사용할 때 다음 사항에 주의해야 한다.

1. 서브쿼리를 괄호로 감싸서 사용한다.
2. 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하고 복수 행 비교 연산자는 서브쿼리의 결과 건수와 상관 없다.
3. 서브쿼리에서는 ORDER BY를 사용하지 못한다. ORDER BY 절은 SELECT 절에서 오직 한 개만 올 수 있기 때문에 ORDER BY 절은 메인쿼리의 마지막 문장에 위치해야 한다.



서브쿼리가 SQL문에서 사용이 가능한 곳은 다음과 같다.

- SELECT 절
- FROM 절
- WHERE 절
- HAVING 절
- ORDER BY 절
- INSERT문의 VALUES 절
- UPDATE문의 SET절

서브쿼리의 종류는 동작하는 방식이나 반환되는 데이터의 형태에 따라 분류할 수 있다.

##### 동작하는 방식에 따른 서브쿼리 분류

| 서브쿼리 종류                  | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| Un-Correlated(비연관) 서브쿼리 | 서브쿼리가 메인쿼리 칼럼을 가지고 있지 않는 형태의 서브쿼리이다.메인쿼리에 값(서브쿼리가 실행된 결과)을 제공하기 위한 목적으로 주로 사용한다. |
| Correlated(연관) 서브쿼리      | 서브쿼리가 메인쿼리 칼럼을 가지고 있는 형태의 서브쿼리이다. 일반적으로 메인쿼리가 먼저 수행되어 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 주로 사용된다. |



서브쿼리는 메인쿼리 안에 포함된 종속적인 관계이기 때문에 논리적인 실행순서는 항상 메인쿼리에서 읽혀진 데이터에 대해 서브쿼리에서 해당 조건이 만족하지를 확인하는 방식으로 수행되어야 한다.

반환되는 데이터의 형태에 따라 서브쿼리는 표와 같이 세 가지로 분류된다.

##### 반환되는 데이터의 형태에 따른 서브쿼리 분류

| 서브쿼리 종류                             | 설명                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| Single Row 서브쿼리(단일 행 서브쿼리)     | 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미한다. 단일 행 서브쿼리는 단일 행 비교 연산자와 함께 사용된다. 단일 행 비교 연산자는 =, <, <=, >, >=, <>이 있다. |
| Multi Row 서브쿼리(다중 행 서브쿼리)      | 서브쿼리의 실행 결과가 여러 건인 서브쿼리를 의미한다. 다중 행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다. 다중 행 비교 연산자에는 IN, ALL, ANY, SOME, EXISTS가 있다. |
| Multi Column 서브쿼리(다중 칼럼 서브쿼리) | 서브쿼리의 실행 결과로 여러 칼럼을 반환한다. 메인쿼리의 조건절에 여러 칼럼을 동시에 비교할 수 있다. 서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼 개수와 칼럼의 위치가 동일해야 한다. |



#### 1. 단일 행 서브쿼리

서브쿼리가 단일 행 비교 연산자 <=, <, =, >=, <>와 함께 사용할 때는 서브쿼리의 결과 건수가 반드시 1건 이하여야 한다.

<u>만약 서브쿼리의 결과 건수가 2건 이상을 반환하면 SQL문은 실행시간 오류가 발생한다.</u>



EX) 정남일 선수가 소속된 팀의 선수들에 대한 정보를 표시하는 문제를 서브쿼리 방식의 SQL문으로 작성하면 다음과 같다.

```SQL
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE TEAM_ID = (SELECT TEAM_ID
FROM PLAYER
WHERE PLAYER_NAME = '정남일')
ORDER BY PLAYER_NAME;
```

```
선수명                                   포지션                   백넘버
---------------------------------------- -------------------- ----------
강철                                     DF                            3
김반                                     MF                           14
김영수                                   MF                           30
김정래                                   GK                           33
김창원                                   DF                            5
김회택                                   DF
꼬레아                                   FW                           16
노병준                                   MF                           22
노상래                                   FW                            8
마시엘                                   DF                           24
서현옥                                   DF
```

정남일 선수의 소속팀을 알아내는 서브쿼리가 먼저 수행되어 정남일 선수의 소속팀 코드가 반환된다.

그뒤 메인쿼리는 서브쿼리에서 반환된 결과를 이용해서 조건을 만족하는 선수들의 정보를 출력한다.

<u>만일, 정남일 선수가 동명이인이었다면 2건 이상의 결과가 반환되어 SQL문은 오류가 발생될 것이다.</u>



테이블 전체에 하나의 그룹함수를 적용할 때는 그 결과 값이 1건이 생성되기 때문에 단일 행 서브쿼리로서 사용 가능하다.



EX) 선수들의 평균키를 알아내는 SQL문과 이 결과를 이용해서 키가 평균 이하의 선수들의 정보를 출력하는 SQL문으로 구성된다.

```SQL
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE HEIGHT <= (SELECT AVG(HEIGHT) FROM PLAYER)
ORDER BY PLAYER_NAME;
```

```
선수명                                   포지션                   백넘버
---------------------------------------- -------------------- ----------
가비                                     MF                           10
강대희                                   MF                           26
강용                                     DF                            2
강정훈                                   MF                           38
강철                                     DF                            3
고규억                                   DF                           29
고민기                                   FW                           24
고종수                                   MF                           22
고창현                                   MF                            8
공오균                                   MF                           22
곽기훈                                   FW                           33
```



#### 2. 다중 행 서브쿼리

서브쿼리의 결과가 2건 이상 반환될 수 있다면 반드시 비교 연산자(IN, ALL, ANY, SOME)와 함께 써야 한다.

##### 다중 행 비교 연산자

| 다중 행 연산자            | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| IN (서브쿼리)             | 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건을 의미한다. (Multiple OR 조건) |
| 비교연산자 ALL (서브쿼리) | 서브쿼리의 결과에 존재한느 모든 값을 만족하는 조건을 의미한다. 비교 연산자로 >를 사용했다면 메인쿼리는 서브쿼리의 모든 결과 값을 만족해야 하므로, 서브쿼리 결과의 최대값보다 큰 모든 건이 조건을 만족한다. |
| 비교연산자 ANY (서브쿼리) | 서브쿼리의 결과에 존재하는 어느 하나의 값이라도 만족하는 조건을 의미한다. 비교연산자로 >를 사용했다면 메인쿼리는 서브쿼리의 값들 중 어떤 값이라도 만족하면 되므로, 서브쿼리의 결과의 최소값보다 큰 모든 건이 조건을 만족한다. (SOME은 ANY와 동일함) |
| EXISTS (서브쿼리)         | 서브쿼리의 결과를 만족하는 값이 존재하는지 여부를 확인하는 조건을 의미한다. 조건을 만족하는 건이 여러 건이더라도 1건만 찾으면 더 이상 검색하지 않는다. |



EX) 선수들 중에서 '정현수'라는 선수가 소속되어 있는 팀 정보를 출력하는 서브쿼리를 작성하면 다음과 같다.

```SQL
SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID = (SELECT TEAM_ID FROM PLAYER WHERE PLAYER_NAME = '정현수')
ORDER BY TEAM_NAME;
```

ERROR -> ORA-01427: single-row subquery returns more than one row

단일 행 하위 질의에 2개 이산의 행이 리턴되었다.

따라서 다중 행 비교 연산자로 바꾸어서 SQL문을 작성하면 된다.

```SQL
SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID IN (SELECT TEAM_ID FROM PLAYER WHERE PLAYER_NAME = '정현수')
ORDER BY TEAM_NAME;
```

```
연고지명
----------------
팀명
--------------------------------------------------------------------------------
영문팀명
--------------------------------------------------------------------------------
전남
드래곤즈
CHUNNAM DRAGONS FC

성남
일화천마
SEONGNAM ILHWA CHUNMA FC
```

실행결과를 보면 정현수라는 이름을 가진 선수가 두 명 존재한다. 

서브쿼리의 실행 결과가 2건 이상 나오는 모든 경우에는 다중 행 연산자를 사용해야 한다.



#### 3. 다중 칼럼 서브쿼리

<u>다중 칼럼 서브쿼리는 서브쿼리의 결과로 여러 개의 칼럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것을 의미한다.</u>



EX) 소속팀별 키가 가장 작은 사람들의 정보를 출력하라.

```SQL
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버, HEIGHT 키
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT) FROM PLAYER GROUP BY TEAM_ID)
ORDER BY TEAM_ID, PLAYER_NAME;
```

```
팀코드 선수명                                   포지션                   백넘버
------ ---------------------------------------- -------------------- ----------
        키
----------
K01    마르코스                                 FW                           44
       170

K01    박정수                                   MF                            8
       170

K02    고창현                                   MF                            8
       170
```

SQL문의 실행 결과를 보면 서브쿼리의 결과값으로 소속팀코드와 소속팀별 가장 작은 키를 의미하는 MIN(HEIGHT)라는 두 개의 칼럼을 반환했다.

메인쿼리에서는 조건절에 TEAM_ID와 HEIGHT 칼럼을 괄호로 묶어서 서브쿼리 결과와 비교하여 원하는 결과를 얻었다.



#### 4. 연관 서브쿼리

<u>연관 서브쿼리는 서브쿼리 내에 메인쿼리 칼럼이 사용된 서브쿼리이다.</u>



EX) 선수 자신이 속한 팀의 평균 키보다 작은 선수들의 정보를 출력하는 SQL문을 연관 서브쿼리를 이용해서 작성해보자.

```SQL
SELECT T.TEAM_NAME 팀명, M.PLAYER_NAME 선수명, M.POSITION 포지션, M.BACK_NO 백넘버, M.HEIGHT 키
FROM PLAYER M, TEAM T
WHERE M.TEAM_ID = T.TEAM_ID
AND M.HEIGHT < (SELECT AVG(HEIGHT) FROM PLAYER S WHERE S.TEAM_ID = M.TEAM_ID
AND S.HEIGHT IS NOT NULL GROUP BY S.TEAM_ID)
ORDER BY 선수명;
```

```
팀명
--------------------------------------------------------------------------------
선수명                                   포지션                   백넘버
---------------------------------------- -------------------- ----------
        키
----------
삼성블루윙즈
가비                                     MF                           10
       177

삼성블루윙즈
강대희                                   MF                           26
       174
```

팀의 평균키를 구하고, 그 평균키와 선수의 키를 비교한 후 출력하거나 출력하지 않는다.

이 작업을 메인쿼리에 존재하는 모든 행에 대해서 반복 수행한다.



EXISTS 서브쿼리는 항상 연관 서브쿼리로 사용된다.

또한 EXISTS 서브쿼리의 특징은 아무리 조건을 만족하는 건이 여러 건이더라도 조건을 만족하는 1건만 찾으면 추가적인 검색을 진행하지 않는다.

EX) 20120501부터 20120502 사이에 경기가 있는 경기장을 조회하는 SQL문.

```SQL
SELECT STADIUM_ID ID, STADIUM_NAME 경기장명
FROM STADIUM A
WHERE EXISTS (SELECT 1 FROM SCHEDULE X WHERE X.STADIUM_ID = A.STADIUM_ID
AND X.SCHE_DATE BETWEEN '20120501' AND '20120502');
```

```
ID
------
경기장명
--------------------------------------------------------------------------------
B01
인천월드컵경기장

B04
수원월드컵경기장

B05
서울월드컵경기장


ID
------
경기장명
--------------------------------------------------------------------------------
C02
부산아시아드경기장
```



#### 5. 그밖에 위치에서 사용하는 서브쿼리



##### 1. SELECT 절에 서브쿼리 사용하기

스칼라 서브쿼리는 한 행, 한 칼럼만을 반환하는 서브쿼리를 말한다.

스칼라 서브쿼리는 칼럼을 쓸 수 있는 대부분의 곳에서 사용할 수 있다.



선수 정보와 해당 선수가 속한 팀의 평균 키를 함께 출력하는 예제로 스칼라 서브쿼리를 설명하면 다음과 같다.

2개의 SQL문으로 구성되어 있으며, 선수들의 정보를 출력한느 메인쿼리 부분과 해당 선수의 소속팀별 평균키를 알아내는 SQL문(서브쿼리 부분)으로 구성된다.

여기서 선수의 소속팀별 평균키를 알아내는 스칼라 서브쿼리는 메인쿼리의 결과 건수만큼 반복수행된다.

```SQL
SELECT PLAYER_NAME 선수명, HEIGHT 키, ROUND((SELECT AVG(HEIGHT) FROM PLAYER X WHERE X.TEAM_ID = P.TEAM_ID), 3) 팀평균키
FROM PLAYER P;
```

```
선수명                                           키   팀평균키
---------------------------------------- ---------- ----------
우르모브                                        180      179.8
윤희준                                          180      179.8
김규호                                          177      179.8
김민성                                          182      179.8
김장관                                          170      179.8
김정효                                          174      179.8
장대일                                          184      179.8
박상수                                          173      179.8
정재영                                          187      179.8
정태민                                          180      179.8
정현우                                          178      179.8
```

<u>스칼라 서브쿼리 또한 단일 행 서브쿼리이기 때문에 결과가 2건 이상 반환되면 오류를 반환한다.</u>



##### 2. FROM 절에서 서브쿼리 사용하기

<u>FROM절에서 사용되는 서브쿼리를 인라인뷰라고 한다.</u>

<u>FROM 절에는 테이블명이 오도록 되어 있는데, 서브쿼리가 자리잡으면 어떻게 될까?</u>

서브쿼리의 결과가 마치 실행 시 에 동적으로 생성된 테이블인 것처럼 사용할 수 있다.

<u>인라인 뷰는 SQL문이 싱행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않는다.</u>

<u>그래서 일반적인 뷰를 정적 뷰라고 하고, 인라인 뷰를 동적 뷰라고도 한다.</u>

<u>인라인 뷰는 테이블 명이 올 수 있는 곳에 사용할 수 있다.</u>

<u>서브쿼리 칼럼은 메인쿼리에 사용할 수 없다고 했으나, 인라인 뷰는 동적으로 생성된 테이블이기 때문에 인라인 뷰를 사용하는 것은 조인 방식을 사용하는 것과 같기 때문에 인라인 뷰의 칼럼은 SQL문을 자유롭게 참조할 수 있다.</u>

EX) K-리그 선수들 중에서 포지션이 미드필더인 선수들의 소속팀명 및 선수 정보를 출력하고자 한다. 인라인 뷰를 활용해서 SQL문을 만들어보자.

```SQL
SELECT T.TEAM_NAME 팀명, P.PLAYER_NAME 선수명, P.BACK_NO 백넘버
FROM (SELECT TEAM_ID, PLAYER_NAME, BACK_NO
FROM PLAYER
WHERE POSITION = 'MF') P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
ORDER BY 선수명;
```

```
팀명
--------------------------------------------------------------------------------
선수명                                       백넘버
---------------------------------------- ----------
삼성블루윙즈
가비                                             10

삼성블루윙즈
강대희                                           26

시티즌
강정훈                                           38
```

포지션이 미드필더 선수들을 인라인 뷰를 통해서 추출하고 인라인 뷰의 결과와 TEAM 테이블과 조인해서 팀명을 출력하고 있다.

<u>인라인 뷰에서는 ORDER BY절을 사용할 수 있다.</u>

<u>인라인 뷰에 먼저 정렬을 수행하고 정렬된 결과 중에서 일부 데이터를 추출하는 것을 TOP-N 쿼리라고 한다.</u>

<u>TOP-N 쿼리를 수행하기 위해서는 정렬 작업과 정렬 결과 중에서 일부 데이터만을 추출할 수 있는 방법이 필요하다.</u>

<u>ORACLE 에서는 ROWNUM이라는 연산자를 통해서 결과로 추출하고자 하는 데이터 건수를 제약할 수 있다.</u>

```SQL
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버, HEIGHT 키
FROM (SELECT PLAYER_NAME, POSITION, BACK_NO, HEIGHT
FROM PLAYER
WHERE HEIGHT IS NOT NULL
ORDER BY HEIGHT DESC)
WHERE ROWNUM <= 5;
```

```
선수명                                   포지션                   백넘버
---------------------------------------- -------------------- ----------
        키
----------
서동명                                   GK                           21
       196

권정혁                                   GK                            1
       195

김석                                     FW                           20
       194


선수명                                   포지션                   백넘버
---------------------------------------- -------------------- ----------
        키
----------
정경두                                   GK                           41
       194

이현                                     GK                            1
       192
```

키를 큰 순으로 정렬 후, 메인쿼리에서 ROWNUM을 사용해서 5명의 선수의 정보마 추출했다.

만약, 다른 선수 중에서 키가 192인 선수가 더 존재하더라도 해당 SQL문에서는 출력되지 않기 때문에 출력을 원한다면 분석 함수의 RANK관련 한수를 사용해야 한다.



##### 3. HAVING 절에서 서브쿼리 사용하기

HAVING 절은 그룹함수와 함께 사용될 때 그룹핑된 결과에 대해 부가적인 조건을 주기 위해서 사용한다.

EX) 편균키가 삼성 블루윙즈팀의 평균키보다 작은 팀의 이름과 해당 팀의 평균키를 구하는 SQL문을 작성하라

```SQL
SELECT P.TEAM_ID 팀코드, T.TEAM_NAME 팀명, AVG(P.HEIGHT) 평균키
FROM PLAYER P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
GROUP BY P.TEAM_ID, T.TEAM_NAME
HAVING AVG(P.HEIGHT) < (SELECT AVG(HEIGHT) FROM PLAYER WHERE TEAM_ID = 'K02');
```

```
팀코드
------
팀명
--------------------------------------------------------------------------------
    평균키
----------
K14
제주유나이티드FC
     169.5

K08
일화천마
178.853659

팀코드
------
팀명
--------------------------------------------------------------------------------
    평균키
----------

K11
경남FC
176.333333

K07
드래곤즈

팀코드
------
팀명
--------------------------------------------------------------------------------
    평균키
----------
178.391304

K13
강원FC
173.666667

K15
```



##### 4. UPDATE 문의 SET 절에서 상요하기.

현재 TEAM 테이블에는 STADIUM_NAME 칼럼이 없다.

TEAM 테이블에 STADIUM_NAME을 추가(ALTER TABLE ADD COLUMN)햇따고 가정하자.

TEAM 테이블에 추가된 STADIUM_NAME의 값을 STADIUM 테이블을 이용해서 변경하고자 할 때 다음과 같디 SQL문을 작성할 수 있다.

```SQL
UPDATE TEAM A
SET A.E_TEAM_NAME = (SELECT X.STADIUM_NAME FROM STADIUM X WHERE X.STADIUM_ID = A.STADIUM_ID);
```

서브쿼리를 사용한 변경 작업을 할 때 서브쿼리의 결과가 NULL을 반환할 경우 해당 컬럼의 결과가 NULL이 될 수 있기 때문에 주의해야 한다.



##### 5. INSERT문의 VALUES절에서 사용하기

PLAYER 테이블에 홍길동이라는 선수를 삽입하고자 한다. 이때 PLAYER_ID의 값을 현재 사용중인 값에 1을 더한 값으로 넣고자 한다.

```SQL
SELECT INTO PLAYER(PLAYER_ID, PLAYER_NAME, TEAM_ID)
VALUES ((SELECT TO_CHAR(MAX(TO_NUMBER(PLAYER_ID))+ 1) FROM PLAYER), '홍길동', 'K06');
```



#### 6. 뷰(VIEW)

테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않다. 뷰는 단지 뷰정의만을 가지고 있다.

질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성하여 질의를 수행한다.

뷰는 실제 데이터를 가지고 있지 않지만 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블이라고도 한다.



##### 뷰 사용 장점

| 뷰의 장점     | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| <u>독립성</u> | <u>테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않아도 된다.</u> |
| <u>편리성</u> | <u>복잡한 질의를 뷰로 생성함으로써 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다.</u> |
| <u>보안성</u> | <u>직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면, 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다.</u> |



뷰는 CREATE VIEW문을 통해서 생성할 수 있다.

```SQL
CREATE VIEW V_PLAYER_TEAM AS
SELECT P.PLAYER_NAME, P.POSITION, P.BACK_NO, P.TEAM_ID, T.TEAM_NAME
FROM PLAYER P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID;
```

해당 뷰는 선수 정보와 해당 선수가 속한 팀명을 함께 추출하는 것이다.

뷰의 명칭은 V_PLAYER_TEAM이다.

뷰는 테이블뿐만 아니라 이미 존재하는 뷰를 참조해서도 생성할 수 있다.

```SQL
CREATE VIEW V_PLAYER_TEAM_FILTER AS
SELECT PLAYER_NAME, POSITION, BACK_NO, TEAM_NAME
FROM V_PLAYER_TEAM
WHERE POSITION IN ('GK', 'MF');
```

V_PLAYER_TEAM_FILTER 뷰는 이미 앞서 생성했던 V_PLAYER_TEAM 뷰를 기반으로 해서 생성된 뷰이다.



뷰를 사용하기 위해서는 해당 뷰의 이름을 이용하면 된다.

```SQL
SELECT PLAYER_NAME, POSITION, BACK_NO, TEAM_ID, TEAM_NAME
FROM V_PLAYER_TEAM
WHERE PLAYER_NAME LIKE '황%';
```



이것은 V_PLAYER_TEAM 뷰에서 성이 황씨인 선수만을 추출하는 SQL문이다.

뷰를 사용하는 경우 DBMS가 내부적으로 SQL문을 다음과 같이 재작성한다.

```SQL
SELECT PLAYER_NAME, POSITION, BACK_NO, TEAM_ID, TEAM_NAME
FROM (SELECT P.PLAYER_NAME, P.POSITION, P.BACK_NO, P.TEAM_ID, T.TEAM_ID
FROM PLAYER P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID)
WHERE PLAYER_NAME LIKE '황%';
```

이와 같은 형태이기에 뷰는 데이터를 저장하지 않고도 데이터를 조회할 수 있다.



뷰를 제거하기 위해서는 DROP VIEW문을 사용한다.

```SQL
DROP VIEW V_PLAYER_TEAM;
DROP VIEW V_PLAYER_TEAM_FILTER;
```

