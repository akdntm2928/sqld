#### 1. 계층형 질의

테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해서 계층형 질의를 사용한다.

<u>계층형 데이터란 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 말한다.</u>

상위 조직과 하위 조직이 나뉜 경우를 보통 말한다.

계층형 모델에는 <u>순환 관계 모델, 계층형 구조, 샘플 데이터</u> 등이 있다.



##### 1. oracle 계층형 질의

oracle은 계층형 질의를 지원하기 위해 다음과 같은 계층형 질의 구문을 제공한다.

```sql
SELECT ..
FROM 테이블
WHERE condition AND condition ...
START WITH condition
CONNECT BY [NOCYCLE] condition AND condition ...
[ORDER SIBLINGS BY column, column, ...]
```

- START WITH 절은 계층 구조 전개의 시작 위치를 정하는 구문이다. 즉, 루트 데이터를 지정한다. (액세스)
- CONNECT BY 절은 다음에 전개될 자식 데이터를 지정하는 구문이다. 자식 데이터는 CONNECT BY 절에 주어진 조건을 만족해야 한다. (조인)
- PRIOR : CONNECT BY 절에 사용되며, 현재 읽은 칼럼을 지정한다. PRIOR 자식 = 부모 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모 -> 자식) 방향으로 전개하는 순방향 전개를 한다. 그리고 PRIOR 부모 = 자식 형태를 사용하면 반대로 자식 데이터에서 부모 데이터(자식 -> 부모) 방향으로 전개하는 역방향 전개를 한다. (오른쪽에서 왼쪽으로)
- NOCYCLE : 데이터를 전개하면서 이미 나타났던 동일한 데이터가 전개 중에 다시 나타난다면 이것을 가리켜 사이클이 형성되었다라고 말한다. 사이클이 발생한 데이터는 런타임 오류가 발생한다. 그렇지만 NOCYCLE를 추가하면 사이클이 발생한 이후의 데이터는 전개하지 않는다.
- ORDER SIBILINGS BY : 형제 노드(동일 LEVEL) 사이에서 정렬을 수행한다.
- WHERE : 모든 전개를 수행한 후에 지정된 조건을 만족하는 데이터만 추출한다. (필터링)



ORACLE은 계층형 질의를 사용할 때 다음과 같은 가상 칼럼을 제공한다.

| 가상 칼럼              | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| LEVEL (DEPTH 알려준다) | 루트 데이터이면 1, 그 하위 데이터이면 2이다. 리프(LEAF) 데이터까지 1씩 증가한다. |
| CONNECT_BY_ISLEAF      | 전개 과정에서 해당 데이터가 리프 데이터이면 1, 그렇지 않으면 0이다. (최하위 데이터) |
| CONNECT_BY_ISCYCLE     | 전개과정에서 자식을 갖게 되는데, 해당 데이터가 조상으로 존재하면 1, 그렇지 않으면 0이다. 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터를 말한다. CYCLE 옵셥을 사용했을 때만 사용할 수 있다. |



다음은 샘플 데이터를 계층형 질의 구문을 이용해서 조회한 것이다. 순방향 전개이다.

여기서는 결과 데이터를 들여쓰기하기 위해 LPAD 함수를 사용했다.

```SQL
SELECT LEVEL, LPAD('', 4 * (LEVEL - 1)) || EMPNO 사원, MGR 관리자, CONNECT_BY_ISLEAF ISLEAF
-- LEVEL에 따라서 들여쓰기
FROM EMP
START WITH MGR IS NULL
-- 루트 데이터는 매니저가 없을 테니
CONNECT BY PRIOR EMPNO = MGR;
-- 그 다음 전개될 자식 데이터
```

```
     LEVEL
----------
사원
--------------------------------------------------------------------------------
    관리자     ISLEAF
---------- ----------
         1
7839
                    0

         2
7566
      7839          0

     LEVEL
----------
사원
--------------------------------------------------------------------------------
    관리자     ISLEAF
---------- ----------

         3
7788
      7566          0

         4
7876
```



다음 예제는 최하위 데이터로부터 자신의 상위관리자를 찾는 역방향 전개이다.

```SQL
SELECT LEVEL, LPAD('', 4 * (LEVEL - 1)) || EMPNO 사원, MGR 관리자, CONNECT_BY_ISLEAF ISLEAF
FROM EMP
START WITH EMPNO = '7876'
CONNECT BY PRIOR MGR = EMPNO;
```

```
     LEVEL
----------
사원
--------------------------------------------------------------------------------
    관리자     ISLEAF
---------- ----------
         1
7876
      7788          0

         2
7788
      7566          0
```

역방향 전개이기 때문에 하위 데이터에서 상위 데이터로 전개된다.

하위 데이터가 루트 데이터이므로 아까와 반대로 레벨이 1이다.



ORACLE은 계층형 질의를 사용할 때 사용자 편의성을 제공하기 위해 다음과 같은 함수를 제공한다.

| 함수                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| SYS_CONNECT_BY_PATH | 루트 데이터부터 현재 전개할 데이터까지의 경로를 표시한다. SYS_CONNECT_BY_PATH(칼럼, 경로분리자) |
| CONNECT_BY_ROOT     | 현재 전개할 데이터의 루트 데이터를 표시한다. 단항 연산자이다. CONNECT_BY_ROOT 칼럼 |

```SQL
SELECT CONNECT_BY_ROOT(EMPNO) 루트사원, SYS_CONNECT_BY_PATH(EMPNO, '\') 경로, EMPNO 사원, MGR 관리자
FROM EMP
START WITH MGR IS NULL
CONNECT BY PRIOR EMPNO = MGR;
```

```
  루트사원
----------
경로
--------------------------------------------------------------------------------
      사원     관리자
---------- ----------
      7839
\7839
      7839

      7839
\7839\7566
      7566       7839
```

START WITH를 통해 추출된 루트 데이터가 1건이기 때문에 루트 사원은 모두 A이다. 

경로는 루트로부터 현재 데이터까지의 경로를 표시한다. 

예를 들어, D의 경로는 A -> C -> D이다.



#### 2. 셀프 조인

셀프 조인이란 동일 테이블 시이의 조인을 말한다.

따라서 FROM 절에 동일 테이블이 두 번 이상 나타난다.

동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 테이블 별칭을 사용해야 한다.

그리고 칼럼에도 모두 테이블 별칭을 사용해서 어느 테이블의 칼럼인지 식별해줘야 한다.



셀프 조인의 기본적인 사용법은 다음과 같다.

```SQL
SELECT ALIAS명1.칼럼명, ALIAS명2.칼럼명, ...
FROM 테이블1 ALIAS명1, 테이블2 ALIAS명2
WHERE ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1;
```

EX)

```SQL
SELECT WORKER.EMPNO 사원번호, WORKER.ENAME 사원명, MANAGER.ENAME 관리자명
FROM EMP WORKER, EMP MANAGER
WHERE WORKER.MGR = MANAGER.EMPNO;
```

사원이라는 테이블 속에는 사원과 관리자가 모두 하나의 사원이라는 개념으로 동일시하여 같이 입력되어 있다.

이것을 이용해 셀프 조인으로 문제를 해결해보면 다음과 같다.

<u>자신과 상위, 차상위 관리자를 같은 줄에 표시하라</u>

이 문제를 해결하기 위해서는 FROM 절에 사원 테이블을 두 번 사용해야 한다.

셀프 조인은 동일한 테이블이지만 개념적으로 두 개의 서로 다른 테이블을 사용하는 것과 동일하다.

동일 테이블을 다른 테이블인 것처럼 처리하기 위해 테이블 별칭을 사용해야 한다.

E1(사원), E2(관리자)

```SQL
SELECT E1.EMPNO 사원, E1.MGR 관리자, E2.MGR 차상위_관리자
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO
ORDER BY E2.MGR DESC, E1.MGR, E1.EMPNO;
```

```
      사원     관리자 차상위_관리자
---------- ---------- -------------
      7566       7839
      7698       7839
      7782       7839
      7788       7566          7839
      7902       7566          7839
      7499       7698          7839
      7521       7698          7839
      7654       7698          7839
      7844       7698          7839
      7900       7698          7839
      7934       7782          7839

      사원     관리자 차상위_관리자
---------- ---------- -------------
      7876       7788          7566
      7369       7902          7566
```

결과 표시를 위해 SELECT 절에 2개의 관리자 칼럼이 사용됐다.

그런데 결과에서 차상위 관리자 데이터가 누락되었다.

<u>E1에서 MGR이 없는 경우 E2와 셀프조인에서 누락.</u>

<u>INNER JOIN을 사용할 경우 자신의 관리자가 존재하지 않는 경우에는 E2 테이블에서 조인할 대상이 존재하지 않기 때문에 해당 데이터는 결과에서 누락된다.</u>

<u>이를 방지하기 위해서는 아우터 조인을 사용해야 한다.</u>

```SQL
SELECT E1.EMPNO 사원, E1.MGR 관리자, E2.MGR 차상위_관리자
FROM EMP E1 LEFT OUTER JOIN EMP E2
ON (E1.MGR = E2.EMPNO)
ORDER BY E2.MGR DESC, E1.MGR, E1.EMPNO;
```

```
      사원     관리자 차상위_관리자
---------- ---------- -------------
      7566       7839
      7698       7839
      7782       7839
      7839
      7788       7566          7839
      7902       7566          7839
      7499       7698          7839
      7521       7698          7839
      7654       7698          7839
      7844       7698          7839
      7900       7698          7839

      사원     관리자 차상위_관리자
---------- ---------- -------------
      7934       7782          7839
      7876       7788          7566
      7369       7902          7566
```

아우터 조인을 사용해서 관리자가 존재하지 않는 데이터까지 모두 결과에 표시되었다.

